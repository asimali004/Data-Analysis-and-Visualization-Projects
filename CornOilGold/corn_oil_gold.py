# -*- coding: utf-8 -*-
"""Corn_Oil_Gold.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/18y_e_yxaGWZ7mdeq-Fwg7R8H0IkPZaYX
"""

from google.colab import drive
drive.mount("/content/gdrive")

import numpy as np
import pandas as pd
pd.set_option('display.max_rows', 500)

def mapper(month):
    return month.strftime('%b')

df = pd.read_csv('/content/gdrive/MyDrive/Fiverr Project 10/CornOilGold.csv')
# df.dtypes
df['Date'] = pd.to_datetime(df['Date'], format='%Y%m')
df.index = df['Date']
df['Month'] =  df.index.month
df['Month_name'] = df.index.month_name()
df.head(10)

"""1. Calculate monthly returns for each of these commodities. Output a tuple (with length = 3) including the arithmetic mean monthly return for these three commodities across the entire observation period. """

def total_return(column):
    """
    comment
    """
    return column.mean()

task1_df = df.groupby(['Month_name'], ).apply(total_return)
print(task1_df)
#task1 = df
#task1['output'] = list(zip(task1.Corn.round(2), task1.Oil.round(2), task1.Gold.round(2)))

task1_df = task1_df.sort_values(by=['Month'])
task1 = (task1_df['Corn'].mean(), task1_df['Oil'].mean(), task1_df['Gold'].mean())

task1

"""2. Output a tuple (length = 3) including the standard deviation for each commodity’s return across the entire observation period. """

task2 = df[['Corn', 'Oil', 'Gold']]
task2 = tuple(task2.std())

task2

"""3. Output a tuple (length = 3) for the returns for these commodities for the month of October, 2008. """

task3 = df[['Corn', 'Oil', 'Gold']]
task3 = task3[task3.index=='2008-10-01']
task3 = (task3['Corn'].values[0], task3['Oil'].values[0], task3['Gold'].values[0])
task3

"""4. Output a tuple (length = 3) for the arithmetic mean monthly returns for each commodity over the calendar year 2009. """

task4 = df[['Corn', 'Oil', 'Gold', 'Month_name', 'Month']]
task4 = task4[task4.index >= '2009-01-01']
task4 = task4[task4.index <= "2009-12-31"]

# task4 = task4.groupby(['Month_name'], ).apply(total_return)
# task4['output'] = list(zip(task4.Corn.round(2), task4.Oil.round(2), task4.Gold.round(2)))
task4 = task4.sort_values(by=['Month'])

task4 = (task4['Corn'].mean(), task4['Oil'].mean(), task4['Gold'].mean())
task4

"""5. Output a tuple (length = 3) for the compounded returns for each commodity over calendar year 2009. """

task5 = df[['Corn', 'Oil', 'Gold']]
task5 = task5[task5.index >= '2009-01-01']
task5 = task5[task5.index <= "2009-12-31"]

task5

from scipy import stats 

task5 = (stats.gmean(task5['Corn']), stats.gmean(task5['Oil']),stats.gmean(task5['Gold']))
task5

"""6. Annualize your answer from question 4 by multiplying the mean monthly returns by 12. Compare this arithmetic yearly return to the compounded (geometric) yearly return from question 5. Output a tuple (length = 3) of the differences between these two ways of calculating annual returns. Be sure to calculate as the geometric return minus the arithmetic return. """

task4 = task4 * 12
task6 = tuple(x-(y*12) for x,y in zip(task5,task4))
task6

"""7. Each month, rank the commodities by their monthly return and assign them to a group with 1 = lowest return and 3 = highest return. For now, this is straightforward with only three commodities every month. In the future, we will group a larger number of commodities into three groups in a similar manner. Create three new monthly data series, one for each commodity, and store the ranking (1, 2, or 3) for each commodity for that month. Output a tuple (length = 3) showing the average ranking score for each commodity across the entire observation period. """

def ranker_corn(df):
    if df[['Corn','Oil', 'Gold']].min() == df['Corn']:
        return 1
    elif df[['Corn','Oil', 'Gold']].max() == df['Corn']:
        return 3
    else:
        return 2

def ranker_oil(df):
    if df[['Corn','Oil', 'Gold']].min() == df['Oil']:
        return 1
    elif df[['Corn','Oil', 'Gold']].max() == df['Oil']:
        return 3
    else:
        return 2
 
def ranker_gold(df):
    if df[['Corn','Oil', 'Gold']].min() == df['Gold']:
        return 1
    elif df[['Corn','Oil', 'Gold']].max() == df['Gold']:
        return 3
    else:
        return 2

task7 = df[['Corn','Oil', 'Gold']].copy()

task7['Rank_corn'] = task7.apply(ranker_corn, axis=1)
task7['Rank_oil'] = task7.apply(ranker_oil, axis=1)
task7['Rank_gold'] = task7.apply(ranker_gold, axis=1)

task_7 = (task7['Rank_corn'].mean(), task7['Rank_oil'].mean(), task7['Rank_gold'].mean())
task_7

"""8. Now we will create trend-following portfolios. Each month, we will follow an investment strategy that buys the future contract for the top-performing commodity in the previous month, and sells short the lowest-performing commodity in the prior month. (Be sure that you are using last month’s ranking variable and not the coincident ranking variable!) Start by forming a monthly time series for each of these three portfolios. For example, you could create a “Lowest” series and store the lowest ranked return each month into that series, and similarly create a “Middle” and “Highest” series including the appropriate returns. Output a tuple (length = 3) with the arithmetic mean monthly returns for these three portfolios, ordered as (lowest, middle, highest). """

task8=task7.copy()
task8["Lowest"]=task8[["Corn","Oil","Gold"]].min(axis=1)
task8["Middle"]=task8[["Corn","Oil","Gold"]].mean(axis=1)
task8["Highest"]=task8[["Corn","Oil","Gold"]].max(axis=1)

task_8 = (task8['Lowest'].mean(), task8['Middle'].mean(), task8['Highest'].mean())
task_8

"""9. Create a series that represents the returns to an investment strategy that, each month, buys the top ranked commodity and sells short the bottom ranked commodity. (This is easily achieved by subtracting the “Lowest” series from the “Highest” series.) Calculate the average annual return (monthly arithmetic return times 12), the annualized standard deviation (the monthly standard deviation times the square root of 12), and the Sharpe ratio (annual return divided by annualized standard deviation) for this portfolio. Output these three summary statistics as a tuple (return, standard deviation, Sharpe ratio).  """

task9=task8.copy()
task9["Strategy_Return"] = task9["Highest"] - task9["Lowest"]
annual_return = task9["Strategy_Return"].mean()*12
annual_std = task9["Strategy_Return"].std() * np.sqrt(12)
sharp_ratio = annual_return/annual_std
output_tuple = (annual_return,annual_std,sharp_ratio)
output_tuple